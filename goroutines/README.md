


### Каналы

Канал — это объект связи, с помощью которого горутины обмениваются данными. Технически это конвейер (или труба), откуда можно считывать или помещать данные. То есть одна горутина может отправить данные в канал, а другая — считать помещенные в этот канал данные.

В go каналы являются указателями. В большинстве своем, когда вам необходимо взаимодействовать с горутиной, вы помещаете канал как аргумент в функцию или метод. Горутина получает этот канал как аргумент, и вам не нужно разыменовывать его для того, чтобы извлечь или передать данные через этот канал.

Если вы попытаетесь считать данные из канала, но в канале будут отсутствовать данные, планировщик заблокирует текущую горутину и разблокирует другую в надежде, что какая-либо горутина передаст данные в канал. То же самое произойдет в случае отправки данных: планировщик заблокирует передающую горутину, пока другая не считает данные из канала.



Попытка передать данные в закрытый канал приведет к возникновению аварийной ситуации, однако операция получения будет работать и с закрытым каналом - будут получены все значения, которые были отправлены, но еще не прочитаны. После получения всех значений из канала, будет возвращаться нулевое значение типа канала.

Наличие буфера позволяет записать в канал определенное количество значений, не вычитывая их при этом.

При отправлении значения в небуферизованный канал отправляющая горутина блокируется до тех пор, пока другая горутина не выполнит получение из этого канала. После этого обе горутины продолжают работать. Верно и обратное, если горутина получает значение, она блокируется, пока значение не будет получено.

Небуферизованные каналы дают более надежные гарантии синхронизации, потому что каждая операция отправления связана с операцией получения. В случае буферизованных каналов, эти операции разделены.

### Блокирование выполнения горутины

* блокирование при записи:
	- горутина, посылающая данные в канал, блокируется, пока другая горутина не прочитает данные из этого канала;
* блокирование при чтении:
	- горутина, получающая данные из канала,  может быть заблокирована до момента получения данных из канала.


### Deadlock (Взаимная блокировка)

Чтение или запись данных в канал блокирует горутину и контроль передается свободной горутине. Представим, что такие горутины отсутствуют, либо они все "спят". В этот момент возникает deadlock, который приведет к аварийному завершению программы.

```go
func main() {
    fmt.Println("main() started")

	/*
	Deadlock:
		c := make(chan string)
		c <- "John"
	т.к. main - горутина, которая эксклюзивно производит операции с каналом.
	*/

	/* no deadlock */
    go func() {
		c := make(chan string)
		c <- "John"
	}()

    fmt.Println("main() stopped")
}
```